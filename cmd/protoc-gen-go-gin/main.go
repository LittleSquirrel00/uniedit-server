package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	genName = "protoc-gen-go-gin"
)

type httpBinding struct {
	Method string
	Path   string
	Body   string

	GinPath string
	Vars    []string
}

func main() {
	var flags flag.FlagSet
	opts := protogen.Options{ParamFunc: flags.Set}

	opts.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			if !hasHTTPRules(f) {
				continue
			}
			generateFile(plugin, f)
		}
		return nil
	})
}

func hasHTTPRules(file *protogen.File) bool {
	for _, svc := range file.Services {
		for _, m := range svc.Methods {
			if rule := getHTTPRule(m); rule != nil {
				return true
			}
		}
	}
	return false
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_gin.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by ", genName, ". DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	ginImportPath := protogen.GoImportPath("github.com/gin-gonic/gin")
	protoHTTPImportPath := protogen.GoImportPath("github.com/uniedit/server/internal/transport/protohttp")

	for _, svc := range file.Services {
		generateService(g, svc, ginImportPath, protoHTTPImportPath)
	}
}

func generateService(g *protogen.GeneratedFile, svc *protogen.Service, ginImportPath, protoHTTPImportPath protogen.GoImportPath) {
	serverName := svc.GoName + "GinServer"

	g.P("type ", serverName, " interface {")
	for _, m := range svc.Methods {
		in := g.QualifiedGoIdent(m.Input.GoIdent)
		out := g.QualifiedGoIdent(m.Output.GoIdent)
		ctx := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: ginImportPath, GoName: "Context"})
		g.P(m.GoName, "(c *", ctx, ", in *", in, ") (*", out, ", error)")
	}
	g.P("}")
	g.P()

	routesType := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: ginImportPath, GoName: "IRoutes"})
	g.P("func Register", svc.GoName, "GinServer(r ", routesType, ", srv ", serverName, ") {")
	for _, m := range svc.Methods {
		rule := getHTTPRule(m)
		if rule == nil {
			continue
		}
		bindings, err := collectBindings(rule)
		if err != nil {
			g.P("panic(", fmt.Sprintf("%q", err.Error()), ")")
			continue
		}
		for i, b := range bindings {
			handlerName := fmt.Sprintf("_%s_%s%d_Gin_Handler", svc.GoName, m.GoName, i)
			g.P("r.Handle(", fmt.Sprintf("%q", strings.ToUpper(b.Method)), ", ", fmt.Sprintf("%q", b.GinPath), ", ", handlerName, "(srv))")
		}
	}
	g.P("}")
	g.P()

	for _, m := range svc.Methods {
		rule := getHTTPRule(m)
		if rule == nil {
			continue
		}
		bindings, err := collectBindings(rule)
		if err != nil {
			continue
		}
		for i, b := range bindings {
			handlerName := fmt.Sprintf("_%s_%s%d_Gin_Handler", svc.GoName, m.GoName, i)
			generateHandler(g, svc, m, b, handlerName, ginImportPath, protoHTTPImportPath)
		}
	}
}

func generateHandler(
	g *protogen.GeneratedFile,
	svc *protogen.Service,
	method *protogen.Method,
	b httpBinding,
	handlerName string,
	ginImportPath, protoHTTPImportPath protogen.GoImportPath,
) {
	serverName := svc.GoName + "GinServer"
	handlerFunc := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: ginImportPath, GoName: "HandlerFunc"})
	ctx := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: ginImportPath, GoName: "Context"})
	req := g.QualifiedGoIdent(method.Input.GoIdent)
	protoBindQuery := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "BindQuery"})
	protoBindVars := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "BindVars"})
	protoBindBody := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "BindBody"})
	abortBind := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "AbortBindError"})
	abortErr := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "AbortServerError"})
	writeOK := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: protoHTTPImportPath, GoName: "WriteOK"})

	g.P("func ", handlerName, "(srv ", serverName, ") ", handlerFunc, " {")
	g.P("return func(c *", ctx, ") {")
	g.P("var in ", req)

	if b.Body != "" {
		g.P("if err := ", protoBindBody, "(c, &in, ", fmt.Sprintf("%q", b.Body), "); err != nil {")
		g.P(abortBind, "(c, err)")
		g.P("return")
		g.P("}")
	} else {
		g.P("if err := ", protoBindQuery, "(c, &in); err != nil {")
		g.P(abortBind, "(c, err)")
		g.P("return")
		g.P("}")
	}

	if len(b.Vars) > 0 {
		g.P("if err := ", protoBindVars, "(c, &in, ", quoteCSV(b.Vars), "); err != nil {")
		g.P(abortBind, "(c, err)")
		g.P("return")
		g.P("}")
	}

	g.P("out, err := srv.", method.GoName, "(c, &in)")
	g.P("if err != nil {")
	g.P(abortErr, "(c, err)")
	g.P("return")
	g.P("}")
	g.P(writeOK, "(c, out)")
	g.P("}")
	g.P("}")
	g.P()
}

func quoteCSV(items []string) string {
	quoted := make([]string, 0, len(items))
	for _, s := range items {
		quoted = append(quoted, fmt.Sprintf("%q", s))
	}
	return strings.Join(quoted, ", ")
}

func getHTTPRule(m *protogen.Method) *annotations.HttpRule {
	if m.Desc.Options() == nil {
		return nil
	}
	ext := proto.GetExtension(m.Desc.Options(), annotations.E_Http)
	rule, ok := ext.(*annotations.HttpRule)
	if !ok || rule == nil {
		return nil
	}
	return rule
}

func collectBindings(rule *annotations.HttpRule) ([]httpBinding, error) {
	var out []httpBinding
	appendRule := func(r *annotations.HttpRule) error {
		b, err := fromRule(r)
		if err != nil {
			return err
		}
		out = append(out, b)
		return nil
	}

	if err := appendRule(rule); err != nil {
		return nil, err
	}
	for _, ar := range rule.AdditionalBindings {
		if ar == nil {
			continue
		}
		if err := appendRule(ar); err != nil {
			return nil, err
		}
	}
	return out, nil
}

func fromRule(rule *annotations.HttpRule) (httpBinding, error) {
	if rule == nil {
		return httpBinding{}, fmt.Errorf("http rule is nil")
	}

	var method, path string
	switch p := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		method, path = "GET", p.Get
	case *annotations.HttpRule_Put:
		method, path = "PUT", p.Put
	case *annotations.HttpRule_Post:
		method, path = "POST", p.Post
	case *annotations.HttpRule_Delete:
		method, path = "DELETE", p.Delete
	case *annotations.HttpRule_Patch:
		method, path = "PATCH", p.Patch
	case *annotations.HttpRule_Custom:
		method, path = strings.ToUpper(p.Custom.Kind), p.Custom.Path
	default:
		return httpBinding{}, fmt.Errorf("unsupported http pattern for selector %q", rule.Selector)
	}

	ginPath, vars, err := toGinPath(path)
	if err != nil {
		return httpBinding{}, err
	}
	return httpBinding{
		Method:  method,
		Path:    path,
		Body:    rule.Body,
		GinPath: ginPath,
		Vars:    vars,
	}, nil
}

func toGinPath(path string) (string, []string, error) {
	var (
		vars []string
		b    strings.Builder
	)

	for i := 0; i < len(path); i++ {
		if path[i] != '{' {
			b.WriteByte(path[i])
			continue
		}
		end := strings.IndexByte(path[i:], '}')
		if end < 0 {
			return "", nil, fmt.Errorf("invalid path template: %s", path)
		}
		end = i + end
		token := path[i+1 : end]

		fieldPath, template, _ := strings.Cut(token, "=")
		fieldPath = strings.TrimSpace(fieldPath)
		if strings.Contains(fieldPath, ".") {
			return "", nil, fmt.Errorf("暂不支持 path 绑定嵌套字段: %s", fieldPath)
		}
		if fieldPath == "" {
			return "", nil, fmt.Errorf("invalid path template: %s", path)
		}

		// 简化处理：默认用 :var。若模板包含 "/" 或 "**"，尝试用 *var 匹配多段。
		if strings.Contains(template, "/") || strings.Contains(template, "**") {
			b.WriteString("*")
			b.WriteString(fieldPath)
		} else {
			b.WriteString(":")
			b.WriteString(fieldPath)
		}
		vars = append(vars, fieldPath)

		i = end
	}

	return b.String(), vars, nil
}
